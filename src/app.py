"""
Trading Analysis Platform.

This Streamlit application provides a platform for interactive financial analysis.
It allows users to:
- Load historical stock data for a given ticker symbol.
- Display candlestick charts with trading volumes.
- Calculate and plot a built-in Relative Strength Index (RSI) indicator.
- Discover, configure, and apply custom technical indicators dynamically.
- Load a pre-trained machine learning model to generate trading signals.
- Trigger the training of a new ML model (currently with default parameters for SPY).

The application heavily utilizes Streamlit's session state (`st.session_state`)
to manage data persistence across user interactions, preventing redundant data
fetches and calculations. The UI is organized into a sidebar for controls
(data loading, indicator configuration, ML operations) and a main page for
displaying charts and data.

Key Session State Variables:
    spy_data (pd.DataFrame): Holds the primary financial data for the selected ticker.
    rsi_period (int): The period used for calculating the RSI.
    rsi_values (pd.Series): The calculated RSI values for the current data.
    available_custom_indicators (dict): Maps names of discovered custom indicator
                                        classes to the classes themselves.
    active_custom_indicators (list): A list of dictionaries, where each dictionary
                                     stores an active custom indicator's name,
                                     its instantiated object, calculated data (pd.Series or pd.DataFrame),
                                     parameters, and a unique ID.
    custom_indicator_param_values (dict): Temporarily stores parameter values entered
                                          in the UI for a selected custom indicator
                                          before it's added.
    ml_model_path (str): The file path to the trained machine learning model.
    ml_signals (pd.DataFrame/pd.Series): Stores trading signals generated by the ML model.
    ml_sequence_length (int): Sequence length for LSTM model input.
    ml_hidden_size (int): Number of features in the LSTM hidden state.
    ml_num_layers (int): Number of LSTM layers.
    ml_dropout (float): Dropout rate for LSTM layers.
"""
import streamlit as st
import pandas as pd

# Add project root to sys.path to allow direct imports from src
import sys
import os
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
if project_root not in sys.path:
    sys.path.insert(0, project_root)

from src.core.data_manager import fetch_spy_data
from src.core.indicator_calculator import calculate_rsi # Will be replaced or augmented by custom indicators
from src.charts.plot_generator import create_candlestick_chart
from src.core.indicator_manager import discover_indicators
from src.core.custom_indicator_interface import CustomIndicator
from src.indicators.saty_phase_oscillator import SatyPhaseOscillator # Added import
import inspect # For inspecting indicator parameters
import subprocess # For running train.py
from src.ml.predict import get_predictions # Import the new function

# --- Page Configuration ---
st.set_page_config(
    page_title="Trading Analysis Platform",
    page_icon="ðŸ“Š",
    layout="wide",
    initial_sidebar_state="expanded"
)

# --- Application State ---
# Using st.session_state to hold data and prevent re-fetching on every interaction.
# See module-level docstring for detailed explanation of session state variables.
if 'spy_data' not in st.session_state:
    st.session_state.spy_data = None
if 'rsi_period' not in st.session_state:
    st.session_state.rsi_period = 14
if 'rsi_values' not in st.session_state:
    st.session_state.rsi_values = None

# Custom Indicator State
if 'available_custom_indicators' not in st.session_state:
    st.session_state.available_custom_indicators = discover_indicators()
if 'active_custom_indicators' not in st.session_state:
    st.session_state.active_custom_indicators = []
if 'custom_indicator_param_values' not in st.session_state:
    st.session_state.custom_indicator_param_values = {}
# ML State
if 'ml_model_path' not in st.session_state:
    st.session_state.ml_model_path = 'models/lstm_model_v1.pth' # Default path
if 'ml_signals' not in st.session_state:
    st.session_state.ml_signals = None
# Default hyperparameters for LSTM model
if 'ml_sequence_length' not in st.session_state:
    st.session_state.ml_sequence_length = 20
if 'ml_hidden_size' not in st.session_state:
    st.session_state.ml_hidden_size = 50
if 'ml_num_layers' not in st.session_state:
    st.session_state.ml_num_layers = 2
if 'ml_dropout' not in st.session_state:
    st.session_state.ml_dropout = 0.2


# --- Helper Functions ---
def load_data(ticker="SPY", period_selection="1y", force_refresh=False): # Renamed period to period_selection
    """
    Loads historical stock data for a given ticker symbol, period, and interval.

    This function fetches data using `fetch_spy_data` and stores it in
    `st.session_state.spy_data`. It also calculates RSI values for the
    'Close' price and stores them in `st.session_state.rsi_values`.

    Args:
        ticker (str, optional): The stock ticker symbol. Defaults to "SPY".
        period_selection (str, optional): The user's period/interval selection from the UI
                                (e.g., "1m", "1y"). Defaults to "1y".
        force_refresh (bool, optional): If True, forces a refresh of the data,
                                        bypassing any cached data. Defaults to False.
    """
    use_cache_cond = not force_refresh

    current_interval = "1d" # Default interval
    current_period = period_selection # Actual period to pass to yfinance

    if period_selection == "1m":
        current_interval = "1m"
        # For 1m data, yfinance typically provides last 7 days, or up to 60 days if period is specified.
        # Let's use "7d" as the period for fetching to ensure we get a decent amount of recent data.
        current_period = "7d"
        st.sidebar.caption(f"Fetching 1-min data for {ticker} for the last 7 days.")

    st.write(f"Loading data for {ticker} (Selection: {period_selection}, Fetch Interval: {current_interval}, Fetch Period: {current_period}, Cache Used: {use_cache_cond})...")
    data = fetch_spy_data(ticker_symbol=ticker, period=current_period, interval=current_interval, use_cache=use_cache_cond) # Pass interval

    if data is not None and not data.empty:
        st.session_state.spy_data = data
        st.success(f"Successfully loaded data for {ticker} ({len(data)} rows, Interval: {current_interval}).")
        # Automatically calculate RSI for the loaded data
        if 'Close' in st.session_state.spy_data.columns:
            st.session_state.rsi_values = calculate_rsi(st.session_state.spy_data['Close'],
                                                        period=st.session_state.rsi_period)
    else:
        st.error(f"Failed to load data for {ticker}.")
        st.session_state.spy_data = None # Clear data on failure
        st.session_state.rsi_values = None


# --- Sidebar ---
# The sidebar contains controls for data loading, indicator configuration, and ML model interactions.
st.sidebar.title("Controls")

# Data loading section: Allows users to specify a ticker and period, and load data.
st.sidebar.header("Data Loading")
selected_ticker = st.sidebar.text_input("Ticker Symbol", value="SPY").upper()
# Added "1m" option, updated default index if necessary (assuming "1y" is still preferred default)
selected_period = st.sidebar.selectbox("Data Period", ["1m", "1mo", "3mo", "6mo", "1y", "2y", "5y", "max"], index=4)

if st.sidebar.button("Load/Refresh Data", key="load_data_button"):
    with st.spinner(f"Fetching data for {selected_ticker} (Period/Interval: {selected_period})..."): # Updated spinner
        load_data(ticker=selected_ticker, period_selection=selected_period, force_refresh=True) # Pass period_selection

# --- Data Export Section ---
st.sidebar.header("Data Export")
if 'spy_data' in st.session_state and st.session_state.spy_data is not None and not st.session_state.spy_data.empty:
    # Prepare data for download
    csv_data = st.session_state.spy_data.to_csv(index=True).encode('utf-8')

    # Determine the actual interval used for fetching for the filename
    current_interval_for_filename = "1d" # Default
    if selected_period == "1m": # selected_period holds the user's dropdown choice
        current_interval_for_filename = "1m"

    # Construct a descriptive filename
    download_filename = f"{selected_ticker}_{selected_period}_{current_interval_for_filename}_data.csv"

    st.sidebar.download_button(
        label="Download Data as CSV",
        data=csv_data,
        file_name=download_filename,
        mime='text/csv',
        key='download_csv_button'
    )
else:
    st.sidebar.info("Load data first to enable download.")

# RSI Configuration: Allows adjustment of the RSI calculation period.
st.sidebar.header("Built-in Indicators")
st.session_state.rsi_period = st.sidebar.slider("RSI Period", min_value=7, max_value=30,
                                                value=st.session_state.rsi_period, key="rsi_period_slider_main")

# Re-calculate RSI if period changes and data exists
if st.session_state.spy_data is not None and 'Close' in st.session_state.spy_data.columns:
    st.session_state.rsi_values = calculate_rsi(st.session_state.spy_data['Close'],
                                                period=st.session_state.rsi_period)

# --- Custom Indicators Section ---
# This section allows users to select, configure, and add custom technical indicators to the chart.
st.sidebar.header("Custom Indicators")
custom_indicator_options = ["None"] + sorted(list(st.session_state.available_custom_indicators.keys()))
selected_indicator_name = st.sidebar.selectbox(
    "Add Indicator",
    options=custom_indicator_options,
    index=0, # Default to "None"
    key="custom_indicator_selector"
)

# Dynamically generate UI for selected custom indicator parameters
if selected_indicator_name != "None" and selected_indicator_name in st.session_state.available_custom_indicators:
    IndicatorClass = st.session_state.available_custom_indicators[selected_indicator_name]
    sig = inspect.signature(IndicatorClass.__init__) # Inspect constructor for parameters

    param_inputs = {}
    st.sidebar.markdown(f"**Parameters for {selected_indicator_name}:**")
    # Create input fields based on parameter types and default values
    for name, param in sig.parameters.items():
        if name == 'self' or name == 'kwargs' or name == 'args': # Skip self and generic collectors
            continue

        default_value = param.default if param.default is not inspect.Parameter.empty else None
        widget_key = f"param_{selected_indicator_name}_{name}" # Unique key for each widget

        if param.annotation == int:
            param_inputs[name] = st.sidebar.number_input(
                f"{name} (int)",
                value=int(default_value) if default_value is not None else 0,
                key=widget_key
            )
        elif param.annotation == float:
            param_inputs[name] = st.sidebar.number_input(
                f"{name} (float)",
                value=float(default_value) if default_value is not None else 0.0,
                format="%.5f",
                key=widget_key
            )
        elif param.annotation == bool:
            param_inputs[name] = st.sidebar.selectbox(
                f"{name} (bool)",
                options=[True, False],
                index=0 if default_value is True else 1,
                key=widget_key
            )
        elif param.annotation == str:
            df_cols_with_empty = [""]
            if st.session_state.spy_data is not None:
                df_cols_with_empty = [""] + list(st.session_state.spy_data.columns)

            val = str(default_value) if default_value is not None else ""

            if name in ['column', 'source'] and st.session_state.spy_data is not None:
                 col_idx = df_cols_with_empty.index(val) if val in df_cols_with_empty else 0
                 param_inputs[name] = st.sidebar.selectbox(
                    f"{name} (data column)",
                    options=df_cols_with_empty,
                    index=col_idx,
                    key=widget_key
                )
            else:
                param_inputs[name] = st.sidebar.text_input(
                    f"{name} (str)",
                    value=val,
                    key=widget_key
                )
        else: # Fallback for unsupported types
            param_inputs[name] = st.sidebar.text_input(
                f"{name} (unknown type - as str)",
                value=str(default_value) if default_value is not None else "",
                key=widget_key,
                help=f"Type {param.annotation} not directly supported. Enter as string."
            )

    st.session_state.custom_indicator_param_values = param_inputs

    # Button to add the configured custom indicator instance
    if st.sidebar.button(f"Add {selected_indicator_name} Instance", key=f"add_custom_indicator_btn"):
        if st.session_state.spy_data is not None and not st.session_state.spy_data.empty:
            try:
                current_params = st.session_state.custom_indicator_param_values
                indicator_instance = IndicatorClass(**current_params)
                calculated_data = indicator_instance.calculate(st.session_state.spy_data)

                # Naming for series/dataframe columns for clarity in charts and data views
                if isinstance(calculated_data, pd.Series) and calculated_data.name is None:
                    calculated_data.name = f"{selected_indicator_name}_{'_'.join(map(str, current_params.values()))}"
                elif isinstance(calculated_data, pd.DataFrame):
                    base_name = f"{selected_indicator_name}_{'_'.join(map(str, current_params.values()))}"
                    calculated_data.columns = [f"{base_name}_{i}" if col_name is None or isinstance(col_name, int) else f"{base_name}_{col_name}" for i, col_name in enumerate(calculated_data.columns)]

                # Store the active indicator instance and its data
                st.session_state.active_custom_indicators.append({
                    "name": selected_indicator_name,
                    "instance": indicator_instance,
                    "data": calculated_data,
                    "params": current_params.copy(),
                    "id": f"{selected_indicator_name}_{len(st.session_state.active_custom_indicators)}" # Unique ID for removal
                })
                st.sidebar.success(f"Added {selected_indicator_name} instance.")
            except Exception as e:
                st.sidebar.error(f"Error adding {selected_indicator_name}: {e}")
        else:
            st.sidebar.warning("Load data before adding indicators.")

# Display and allow removal of active custom indicators
if st.session_state.active_custom_indicators:
    st.sidebar.markdown("---")
    st.sidebar.markdown("**Active Custom Indicators:**")

    for i, indicator_info in reversed(list(enumerate(st.session_state.active_custom_indicators))):
        params_str = ", ".join(f"{k}={v}" for k, v in indicator_info['params'].items())
        label = f"{indicator_info['name']}({params_str})"

        col1, col2 = st.sidebar.columns([0.85, 0.15])
        col1.text(label[:40] + "..." if len(label) > 40 else label)
        if col2.button("X", key=f"remove_custom_ind_{indicator_info['id']}", help="Remove this indicator"):
            st.session_state.active_custom_indicators.pop(i)
            st.experimental_rerun()

    if st.sidebar.button("Clear All Custom Indicators", key="clear_all_custom_btn"):
        st.session_state.active_custom_indicators = []
        st.experimental_rerun()

# --- ML Section ---
# This section provides controls for loading a pre-trained ML model, generating signals,
# and optionally triggering a new model training process.
st.sidebar.header("Machine Learning")
st.session_state.ml_model_path = st.sidebar.text_input(
    "ML Model Path",
    value=st.session_state.ml_model_path,
    key="ml_model_path_input"
)

if st.sidebar.button("Generate & Display ML Signals", key="generate_ml_signals"):
    if st.session_state.spy_data is not None and not st.session_state.spy_data.empty:
        if os.path.exists(st.session_state.ml_model_path):
            with st.spinner("Generating ML signals..."):
                try:
                    # Generate predictions using the specified model and data
                    st.session_state.ml_signals = get_predictions(
                        raw_data_df=st.session_state.spy_data,
                        model_path=st.session_state.ml_model_path,
                        sequence_length=st.session_state.ml_sequence_length,
                        hidden_size=st.session_state.ml_hidden_size,
                        num_layers=st.session_state.ml_num_layers,
                        dropout=st.session_state.ml_dropout
                    )
                    if st.session_state.ml_signals is not None and not st.session_state.ml_signals.empty:
                        st.sidebar.success("ML signals generated.")
                    else:
                        st.sidebar.warning("ML signals generated but were empty.")
                except FileNotFoundError as fnf_error:
                    st.sidebar.error(f"ML Error: {fnf_error}")
                except Exception as e:
                    st.sidebar.error(f"ML signal generation failed: {e}")
        else:
            st.sidebar.error(f"ML Model not found at: {st.session_state.ml_model_path}")
    else:
        st.sidebar.warning("Load stock data first.")

# Optional: Button to trigger training of a new ML model
if st.sidebar.button("Train New ML Model (SPY - Default Params)", key="train_ml_model"):
    # ML training should ideally use consistent daily data for now.
    # Construct path to the daily cache file for the selected_ticker or SPY.
    train_ticker_for_path = selected_ticker if selected_ticker == "SPY" else "SPY" # Prioritize SPY for training if not current
    spy_data_path = f"data/cache/{train_ticker_for_path}_1d.csv" # Explicitly use 1d interval for training path

    if selected_ticker != "SPY":
        st.sidebar.warning(f"Training is hardcoded for SPY. Using SPY_1d.csv. Ensure SPY 1-day data is cached (load SPY with 1y period).")

    if not os.path.exists(spy_data_path) and selected_ticker == "SPY":
        # If SPY is selected, but its 1d cache doesn't exist, try the general selected_ticker path with 1d.
        # This case might occur if user selected SPY, then "1m", then wants to train.
        spy_data_path = f"data/cache/{selected_ticker}_1d.csv"


    if os.path.exists(spy_data_path):
        st.sidebar.info(f"Starting ML model training using {spy_data_path}... This may take a while.")
        try:
            # Command to run the training script
            command = [
                sys.executable, "src/ml/train.py",
                "--data_path", spy_data_path,
            ]
            process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            stdout, stderr = process.communicate() # Wait for completion

            if process.returncode == 0:
                st.sidebar.success("ML model training completed successfully.")
                st.session_state.ml_model_path = 'models/lstm_model_v1.pth' # Update to default path
                st.sidebar.info(f"Model likely saved to {st.session_state.ml_model_path}.")
            else:
                st.sidebar.error(f"ML model training failed. Error:\n{stderr}")
        except Exception as e:
            st.sidebar.error(f"Error launching training process: {e}")
    else:
        st.sidebar.error(f"SPY data not found at {spy_data_path}. Load SPY data to enable training.")


# --- Main Page ---
# The main page displays the title, candlestick chart, and raw data expanders.
st.title(f"ðŸ“Š {selected_ticker} Financial Analysis")

# Initial data load for SPY if no data is currently in session state
if st.session_state.spy_data is None:
    with st.spinner("Performing initial data load for SPY (1 year, 1 day interval)..."): # Updated spinner
        load_data(ticker="SPY", period_selection="1y") # Default load uses 1d interval implicitly

# Display Chart if data is available
if st.session_state.spy_data is not None:
    st.header("Candlestick Chart with Indicators")

    rsi_to_plot = st.session_state.get('rsi_values', None)

    # Prepare custom indicators' data for the plotting function
    custom_indicators_to_plot = []
    for ind_info in st.session_state.active_custom_indicators:
        # --- Start of temporary diagnostic code ---
        st.write(f"--- Debug: Processing Indicator ---")
        st.write(f"Name: {ind_info.get('name', 'N/A')}")
        st.write(f"Instance Type: {type(ind_info.get('instance'))}")

        is_saty_instance = False
        if 'instance' in ind_info and ind_info['instance'] is not None:
            try:
                # Make sure SatyPhaseOscillator is correctly imported in this scope
                from src.indicators.saty_phase_oscillator import SatyPhaseOscillator as SPO_Diagnostic_Check
                is_saty_instance = isinstance(ind_info['instance'], SPO_Diagnostic_Check)
            except ImportError:
                st.write("Error: Could not import SatyPhaseOscillator for diagnostic check.")
                is_saty_instance = False # Or handle error appropriately

        st.write(f"Is SatyPhaseOscillator instance? {is_saty_instance}")
        st.write(f"Data Type: {type(ind_info.get('data'))}")
        st.write(f"--- End Debug ---")
        # --- End of temporary diagnostic code ---

        # Check if the indicator is SatyPhaseOscillator by instance type
        if isinstance(ind_info['instance'], SatyPhaseOscillator):
            # ind_info['data'] is now the dictionary from SatyPhaseOscillator.calculate()
            custom_indicators_to_plot.append({
                "name": ind_info['name'],  # Or a more specific name
                "plot_type": "saty_phase_oscillator", # Crucial for plot_generator
                "data_dict": ind_info['data'],   # Pass the entire dictionary
                "params": ind_info['params']     # Pass constructor parameters
            })
        elif isinstance(ind_info['data'], pd.Series): # Existing logic for simple series
            custom_indicators_to_plot.append({
                "name": ind_info['data'].name if ind_info['data'].name else ind_info['name'],
                "series": ind_info['data']
                # 'plot_type' will default to 'simple_series' in create_candlestick_chart
            })
        elif isinstance(ind_info['data'], pd.DataFrame): # Existing logic for other DataFrames
            # This section should NOT process the Saty Oscillator if it was previously returning a DataFrame.
            # The check for SatyPhaseOscillator instance above handles it first.
            for col in ind_info['data'].columns:
                series_data = ind_info['data'][col]
                custom_indicators_to_plot.append({
                    "name": series_data.name if series_data.name else f"{ind_info['name']}_{col}",
                    "series": series_data
                    # 'plot_type' will default to 'simple_series' in create_candlestick_chart
                })
        else:
            st.warning(f"Indicator {ind_info['name']} produced an unexpected data type: {type(ind_info['data'])}. Cannot plot.")

    # Create and display the main financial chart
    chart_fig = create_candlestick_chart(
        df=st.session_state.spy_data,
        ticker_symbol=selected_ticker,
        rsi_series=rsi_to_plot,
        rsi_period=st.session_state.rsi_period,
        custom_indicators_data=custom_indicators_to_plot,
        ml_signals=st.session_state.get('ml_signals')
    )
    st.plotly_chart(chart_fig, use_container_width=True)

    # Expanders to view raw and indicator data tables
    with st.expander(f"View Raw Data for {selected_ticker}"):
        st.dataframe(st.session_state.spy_data)

    if rsi_to_plot is not None:
        with st.expander(f"View RSI Data (Period: {st.session_state.rsi_period})"):
            st.dataframe(rsi_to_plot)

    if custom_indicators_to_plot:
        with st.expander("View Custom Indicator Data"):
            for ind_data_item in custom_indicators_to_plot: # Renamed to avoid conflict with outer 'ind_data' if any
                st.markdown(f"**{ind_data_item['name']}**")
                if ind_data_item.get('plot_type') == 'saty_phase_oscillator':
                    # For SatyPhaseOscillator, display its dictionary components or a summary
                    # For now, let's display the main oscillator Series and compression_tracker for quick view
                    if 'data_dict' in ind_data_item and isinstance(ind_data_item['data_dict'], dict):
                        if 'oscillator' in ind_data_item['data_dict']:
                             st.markdown("Oscillator:")
                             st.dataframe(ind_data_item['data_dict']['oscillator'])
                        if 'compression_tracker' in ind_data_item['data_dict']:
                             st.markdown("Compression Tracker:")
                             st.dataframe(ind_data_item['data_dict']['compression_tracker'])
                        # Could add more elements from data_dict if needed for display here
                    else:
                        st.text("Saty Phase Oscillator data is not in the expected dictionary format.")
                elif 'series' in ind_data_item: # For simple series indicators
                    st.dataframe(ind_data_item['series'])
                # Potentially handle other complex types if they are added later
                else:
                    st.text("Data format not recognized for display in expander.")
else:
    st.warning(f"No data loaded for {selected_ticker}. Please load data using the sidebar controls.")

st.sidebar.markdown("---")
st.sidebar.info("Built with Streamlit")

# Command to run this Streamlit application: streamlit run src/app.py
